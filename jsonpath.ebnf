jsonpath
    = absolute path
    | relative path
    ;

absolute path
    = root step, { qualified step }
    ;

root step
    = "$", [ predicate expression ]
    ;

qualified step
    = recursive step
    | relative step
    ;

recurisive step
    = "..", step
    ;

relative step
    = ".", step
    ;

relative path
    = ( relative head step | step ), { qualified step }
    ;

relative head step
    = "@" , [ predicate expression ]
    ;

step
    = transformer
    | ( selector, [ predicate expression ] )
    ;

transformer
    = "=", value
    ;

object
    = "{",  [ key value, { ",", key value } ], "}"
    ;

key value
    = string, ":", value
    ;

array
    = "[", [ value, { ",", value } ], "]"
    ;

value
    = array
    | object
    | additive expr
    ;

selector
    = tag selector
    | anchor selector
    | type selector
    | name selector
    ;

tag selector
    = "!", name
    ;

anchor selector
    = "&", name
    ;

type selector
    = type, "()"
    ;

type
    = "object"
    | "array"
    | "string"
    | "number"
    | "integer"
    | "decimal"
    | "timestamp"
    | "boolean"
    | "null"
    ;

name selector
    = wildcard
    | name
    ;

wildcard
    = "*"
    ;

name
    = "'", quoted name character, { quoted name character }, "'"
    | name character, { name character }
    ;

quoted name character
    = ? any unicode character except ' or control characters ?
    | "\'"
    | escape
    ;

name character
    = ? any unicode character except . or [ or control characters ?
    ;

predicate expression
    = "[", predicate, "]"
    | filter expression
    ;

predicate
    = wildcard
    | subscript
    | slice
    | join
    ;

subscript
     = signed integer
     ;

slice
    = [ signed integer ], ":", [ signed integer ], [ ":", [ non-zero signed integer ] ]
    ;

join
    = additive expr, ",", additive expr, { ",", additive expr }
    ;

filter expression
    = "?(", or expr, ")"
    ;

or expr
    = and expr, [ "or", or expr ]
    ;

and expr
    = comparison expr, [ "and", and expr ]
    ;

comparison expr
    = additive expr, [ comparison op, comparison expr ]
    ;

comparison op
    = ">"
    | "<"
    | ">="
    | "<="
    | "="
    | "!="
    ;

additive expr
    = multiplicative expr, [ additive op, additive expr ]
    ;

additive op
    = "+"
    | "-"
    ;

multiplictive expr
    = unary expr, [ multiplicative op, multiplicative expr ]
    ;

multiplicative op
    = "*"
    | "/"
    | "%"
    ;

unary expr
    = relative path
    | scalar
    ;

scalar
    = number
    | string
    | boolean
    | "null"
    ;

number
    = signed integer, [ fractional part ], [ exponent ]
    ;

fractional part
    = ".", digit, { digit }
    ;

exponent
    = e, digit, { digit }
    ;

e
    = "e" | "E", [ "+" | "-" ]
    ;

string
    = """, { character | escape }, """
    ;

character
    = ? any unicode character except " or \ or control characters ?
    ;

escape
    = "\""
    | "\\"
    | "\/"
    | "\ "
    | "\_"
    | "\0"
    | "\a"
    | "\b"
    | "\e"
    | "\f"
    | "\n"
    | "\r"
    | "\t"
    | "\v"
    | "\L"
    | "\N"
    | "\P"
    | "\x", 2 * hex digit
    | "\u", 4 * hex digit
    | "\U", 8 * hex digit
    ;

hex digit
    = 2 * ( digit |  hex lower | hex upper )
    ;

boolean
    = "true"
    | "false"
    ;

integer
    = [ "+" ], ( "0" | digit one to nine, { digit } )
    ;

signed integer
    = [ "-" ], integer
    ;

non-zero signed integer
    = [ "-" ], digit one to nine, { digit }
    ;

digit one to nine
    = "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
    ;

digit
    = "0" | digit one to nine
    ;

hex lower
    = "a" | "b" | "c" | "d" | "e" | "f"
    ;

hex upper
    = "A" | "B" | "C" | "D" | "E" | "F"
    ;

